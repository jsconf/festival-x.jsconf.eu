----

# THIS FILE WAS GENERATED AUTOMATICALLY.
# CHANGES MADE HERE WILL BE OVERWRITTEN.

template: pages/speaker.html.njk
title: >-
  Chris Sun: CANCELLED: Developer above the Sea of Client-side Fog: Frontend
  Observability for User Happiness
data:
  published: false
  reviewed: false
  order: null
  firstname: Chris
  lastname: Sun
  talkTitle: >-
    CANCELLED: Developer above the Sea of Client-side Fog: Frontend
    Observability for User Happiness
  coSpeakers: null
  twitterHandle: 'http://twitter.com/daiyitastic'
  githubHandle: 'https://github.com/daiyi'
  homepage: 'https://daiyi.co'
  potraitImageUrl: 'https://daiyi.co/static/daiyi_glacier.jpg'
  caption: null
  name: Chris Sun
  image:
    filename: chris-sun-2460cfb9.jpg
    filename_500: chris-sun-2460cfb9-500.jpg
    filename_1000: chris-sun-2460cfb9-1000.jpg
    filename_square_1000: chris-sun-2460cfb9-1000-square.jpg
    filename_square_500: chris-sun-2460cfb9-500-square.jpg
    filename_square_200: chris-sun-2460cfb9-200-square.jpg
    width: 400
    height: 400
    originalType: jpg
  web:
    twitter:
      handle: daiyitastic
      url: 'https://twitter.com/daiyitastic'
    github:
      handle: daiyi
      url: 'https://github.com/daiyi'
    homepage:
      handle: daiyi.co
      url: 'https://daiyi.co'
filename: /preview/7fd3f648bf3c5f7e15b787e161e094a453ef6fcb-secret.html
yt: {}

----

**We apologise, but this talk has been cancelled**

How fast and reliable your backend is doesn't matter if you haven't found a way
to pass those optimisations on to your users. As heavy-lifting application
logic moves increasingly beyond the monitored server to the client-side
shadowlands, traditional metrics no longer sufficiently capture the story of
your application's performance. How can you gain clarity into how your code
behaves in production, across a potpourri of device species, workflows, behind
a shroud of complex js logic, in the hands of your users?

I'll talk about strategies for instrumenting your front-end so you can ask
questions of your code after it is thrown over the chasm into userland.
Client-side observability can not only expose user unhappiness bugs, it can
focus product decisions, empower engineering teams during the development
cycle, encourage a positive culture of code ownership, and surface higher-level
usability-impacting issues that tests and error tracking alone won't capture.